name: CI

env:
    GOLANGCI_LINT_VERSION: "2.7.0"
    GO_MIN_VERSION: "1.25.5"

on:
    workflow_dispatch:
        inputs:
            os:
                description: "OS"
                required: true
                default: Linux
                type: choice
                options:
                    - Linux
                    - macOS
                    - Windows
    pull_request:
        branches: ["*"]
        types: ["opened", "synchronize", "reopened"]
    push:
        branches: ["master"]
        tags: ["v[0-9]+.[0-9]+.[0-9]+", "**/v[0-9]+.[0-9]+.[0-9]+"]

permissions:
    contents: read

run-name: ${{ (github.event_name == 'workflow_dispatch' && format('Manual Run for {0} {1} {2}', github.event.inputs.os, github.ref_name, github.sha)) || (github.event_name == 'pull_request' && format('PR {0} {1}', github.event.number, github.sha)) || (github.event_name == 'push' && format('Push {0} {1}', github.ref, github.sha)) }}

jobs:
    ci:
        runs-on: ${{ (github.event_name != 'workflow_dispatch' && 'ubuntu-latest') ||  (github.event.inputs.os == 'Linux' && 'ubuntu-latest') || (github.event.inputs.os == 'Windows' && 'windows-latest') || (github.event.inputs.os == 'macOS' && 'macos-latest') }}
        steps:
            # Checkout
            - uses: actions/checkout@v4
              name: Checkout
              with:
                  fetch-depth: 1

            # Restore (and later save) cache
            # We cache Go Modules, Go Build Cache, and golangci-lint cache
            - uses: actions/cache@v4
              if: runner.os == 'Linux'
              name: Restore Cache [Linux]
              with:
                  path: |
                      ~/.cache/go-build
                      ~/.cache/golangci-lint
                      ~/go/pkg/mod
                  key: ${{ runner.os }}-go-${{ hashFiles('**/go.mod') }}
                  restore-keys: |
                      ${{ runner.os }}-go
              continue-on-error: true
            - uses: actions/cache@v4
              if: runner.os == 'macOS'
              name: Restore Cache [macOS]
              with:
                  path: |
                      ~/Library/Caches/go-build
                      ~/Library/Caches/golangci-lint
                      ~/go/pkg/mod
                  key: ${{ runner.os }}-go-${{ hashFiles('**/go.mod') }}
                  restore-keys: |
                      ${{ runner.os }}-go
              continue-on-error: true
            - uses: actions/cache@v4
              if: runner.os == 'Windows'
              name: Restore Cache [Windows]
              with:
                  path: |
                      ~\AppData\Local\go-build
                      ~\AppData\Local\golangci-lint
                      ~\go\pkg\mod
                  key: ${{ runner.os }}-go-${{ hashFiles('**/go.mod') }}
                  restore-keys: |
                      ${{ runner.os }}-go
              continue-on-error: true

            # Setup Go
            - uses: actions/setup-go@v5
              name: Setup Go
              with:
                  go-version: ${{ env.GO_MIN_VERSION }}
                  cache: false # We are not using cache from this action as it does not restore cache on dependencies change at all

            # Setup GolangCI-Lint
            - name: Install GolangCI-Lint
              shell: python -u {0}
              run: |
                  # Download pre-built binary for GolangCI-Lint

                  import os
                  import platform
                  import shutil
                  import subprocess
                  import tarfile
                  import zipfile
                  from pathlib import Path
                  from urllib.request import urlretrieve

                  version = os.getenv("GOLANGCI_LINT_VERSION")

                  go_path = (
                      subprocess.run(["go", "env", "GOPATH"], capture_output=True, text=True, check=True)
                      .stdout.removesuffix("\n")
                      .removesuffix("\r")
                  )
                  go_bin_path = Path(go_path) / "bin"


                  def get_asset_URL() -> tuple[str, str]:
                      os_name = platform.system()

                      if os_name == "Linux":
                          platform_name = "linux"
                          ext = "tar.gz"
                      elif os_name == "Darwin":
                          platform_name = "darwin"
                          ext = "tar.gz"
                      elif os_name == "Windows":
                          platform_name = "windows"
                          ext = "zip"

                      machine = platform.machine()

                      if (
                          machine.lower() == "x86_64"
                          or machine.lower() == "amd64"
                          or machine.lower() == "x64"
                      ):
                          platform_arch = "amd64"
                      elif (
                          machine.lower() == "x86"
                          or machine.lower() == "i386"
                          or machine.lower() == "i686"
                      ):
                          platform_arch = "386"
                      elif machine.lower() == "arm64" or machine.lower() == "aarch64":
                          platform_arch = "arm64"

                      try:
                          return (
                              f"https://github.com/golangci/golangci-lint/releases/download/v{version}/golangci-lint-{version}-{platform_name}-{platform_arch}.{ext}",
                              ext,
                          )
                      except NameError:
                          raise Exception("Invalid Platform/Architecture")


                  asset_url, ext = get_asset_URL()
                  print(f"Downloading GolangCI-Lint from {asset_url}")

                  tmp_file, _ = urlretrieve(asset_url)
                  print(f"Downloaded {asset_url}")

                  temp_folder = Path(tmp_file).parent
                  internal_folder = (
                      (asset_url.split("/"))[-1].removesuffix(".zip").removesuffix(".tar.gz")
                  )
                  temp_subfolder = internal_folder + Path(tmp_file).name
                  temp_file_path = temp_folder / temp_subfolder

                  os.mkdir(temp_file_path)

                  if ext == "zip":
                      with zipfile.ZipFile(tmp_file, "r") as zip_object:
                          zip_object.extractall(path=temp_file_path)
                  else:
                      with tarfile.open(tmp_file, "r:gz") as tarfile_object:
                          tarfile_object.extractall(path=temp_file_path, filter="fully_trusted")

                  os.remove(tmp_file)

                  if ext == "zip":
                      app_file = "golangci-lint.exe"
                  else:
                      app_file = "golangci-lint"

                  if (go_bin_path / app_file).is_file():
                      print(f"Removing the pre-existing {go_bin_path / app_file}")
                      os.remove(go_bin_path / app_file)

                  shutil.move(
                      temp_file_path / internal_folder / app_file,
                      go_bin_path,
                  )
                  print(f"Moved `{app_file}` to {go_bin_path}")
                  shutil.rmtree(temp_file_path)

            # Install go-ci-tool using `go install`
            - name: Install go-ci-tool
              env:
                  VERSION_SUBSTITUION: "main.version=0.0.0"
                  GO_MIN_VERSION_SUBSTITUTION: "github.com/ram-nad/go-monorepo/go-ci-tool/constants.minGoVersion=${{ env.GO_MIN_VERSION }}"
                  GOLANG_CI_LINT_VERSION_SUBSTITUTION: "github.com/ram-nad/go-monorepo/go-ci-tool/constants.minGolangCILintVersion=${{ env.GOLANGCI_LINT_VERSION }}"
              shell: bash
              run: |
                  # `go install` go-ci-tool
                  go install -trimpath -buildvcs=false -ldflags="-w -X $VERSION_SUBSTITUION -X $GO_MIN_VERSION_SUBSTITUTION -X $GOLANG_CI_LINT_VERSION_SUBSTITUTION" github.com/ram-nad/go-monorepo/go-ci-tool@master

            # Validate the setup
            - name: Check Tools
              run: go-ci-tool check-tools

            # Get changed files for pull request
            - name: Git Diff [PR]
              if: github.event_name == 'pull_request'
              shell: bash
              run: |
                  # Get Git Diff

                  git fetch --no-tags --prune --depth=1 origin +refs/heads/${{ github.event.pull_request.base.ref }}
                  git --no-pager diff --no-color --name-only --output=diff.txt origin/${{ github.event.pull_request.base.ref }}..
            # Get changed files for push (if ref existed previously)
            - name: Git Diff [Push]
              if: github.event_name == 'push' && github.event.before != '0000000000000000000000000000000000000000'
              shell: bash
              run: |
                  # Get Git Diff

                  git fetch --no-tags --prune --depth=1 origin ${{ github.event.before }}
                  git --no-pager diff --no-color --name-only --output=diff.txt ${{ github.event.before }}..

            # Output Git Diff
            - name: Output Git Diff [If Exists]
              if: (github.event_name == 'pull_request') || (github.event_name == 'push' && github.event.before != '0000000000000000000000000000000000000000')
              shell: bash
              run: |
                  # Echo Git Diff

                  echo "::group::Show Git Diff"
                  cat diff.txt
                  echo "::endgroup::"

            # Process only changed modules for pull request and pushes with pre-existing commits
            # Process all modules for workflow_dispatch and new ref pushes
            - name: Get Modules to Check
              env:
                  NO_COLOR: "1"
              run: |
                  # List Modules

                  go-ci-tool list-modules --diff diff.txt --skip-no-file-error >modules.txt

            - name: Echo Modules
              shell: bash
              run: |
                  # Echo Modules

                  echo "::group::Changed Modules"
                  cat modules.txt
                  echo "::endgroup::"

            # Run Checks for Go Modules
            - name: Run CI
              shell: python -u {0}
              run: |
                  # CI

                  import subprocess
                  import textwrap
                  import os

                  def RunCommand(module: str, arg: str) -> bool:
                      p = subprocess.Popen(["go-ci-tool", "module", "-m", module, arg],
                                      stdin=subprocess.DEVNULL,
                                      stderr=subprocess.STDOUT
                                      )
                      return p.wait() == 0

                  def CheckVersion(module: str) -> bool:
                      return RunCommand(module, "--version")

                  def CheckLocalReplace(module: str) -> bool:
                      return RunCommand(module, "--check-local-replace")

                  def Download(module: str) -> bool:
                      return RunCommand(module, "--download")

                  def ModIsTidy(module: str) -> bool:
                      return RunCommand(module, "--is-tidy")

                  def Lint(module: str) -> bool:
                      return RunCommand(module, "--lint")

                  def Test(module: str) -> bool:
                      return RunCommand(module, "--test")

                  def Build(module: str) -> bool:
                      return RunCommand(module, "--build")

                  def Run(module: str) -> dict:
                      print("\n" + '{:=^60}'.format(f" Module: {module} "))
                      print(f"::group::Check Go Version for {module}")
                      checkVersion = CheckVersion(module)
                      print(f"::endgroup::")

                      print(f"::group::Check local replace directives in go.mod for {module}")
                      checkLocalReplace = CheckLocalReplace(module)
                      print(f"::endgroup::")

                      if checkLocalReplace != True:
                          return {
                              "checkVersion": checkVersion,
                              "checkLocalReplace": checkLocalReplace,
                          }

                      print(f"::group::Check go.mod is tidy for {module}")
                      modIsTidy = ModIsTidy(module)
                      print(f"::endgroup::")

                      print(f"::group::Download dependencies for {module}")
                      download = Download(module)
                      print(f"::endgroup::")

                      if download != True:
                          return {
                              "checkVersion": checkVersion,
                              "checkLocalReplace": checkLocalReplace,
                              "modIsTidy": modIsTidy,
                              "download": download,
                          }

                      print(f"::group::Lint {module}")
                      lint = Lint(module)
                      print(f"::endgroup::")

                      print(f"::group::Run Tests for {module}")
                      test = Test(module)
                      print(f"::endgroup::")

                      if test != True:
                          return {
                              "checkVersion": checkVersion,
                              "checkLocalReplace": checkLocalReplace,
                              "download": download,
                              "modIsTidy": modIsTidy,
                              "lint": lint,
                              "test": test,
                          }

                      print(f"::group::Check Build for {module}")
                      build = Build(module)
                      print(f"::endgroup::")

                      return {
                          "checkVersion": checkVersion,
                          "checkLocalReplace": checkLocalReplace,
                          "download": download,
                          "modIsTidy": modIsTidy,
                          "lint": lint,
                          "test": test,
                          "build": build
                      }

                  modules = []

                  try:
                      f = open("modules.txt")
                  except:
                      modules = subprocess.run(["./run-go-tool", "list-modules"], stdout=subprocess.PIPE).stdout.decode().splitlines()
                  else:
                      with f:
                          modules = f.readlines()

                  output = ""
                  allSuccess = True

                  for module in modules:
                      module = module.strip()
                      run = Run(module)
                      success = bool(run.get("checkLocalReplace") and run.get("download") and run.get("modIsTidy") and run.get("lint") and run.get("build"))
                      allSuccess = allSuccess and success
                      moduleOutput = f'''
                      <details>
                      <summary><h3>{module} {':white_check_mark:' if success else ':x:'}</h3></summary>
                      <strong>Go version {':white_check_mark:' if run.get("checkVersion") else ':warning:' if run.get("checkVersion") is None else ':x:'}</strong><br>
                      <strong>No local replaces in go.mod {':white_check_mark:' if run.get("checkLocalReplace") else ':warning:' if run.get("checkLocalReplace") is None else ':x:'}</strong><br>
                      <strong>go.mod is tidy {':white_check_mark:' if run.get("modIsTidy") else ':x:' if run.get("modIsTidy") is not None else ':warning:'}</strong><br>
                      <strong>Download dependencies {':white_check_mark:' if run.get("download") else ':x:' if run.get("download") is not None else ':warning:'}</strong><br>
                      <strong>Lint {':white_check_mark:' if run.get("lint") else ':x:' if run.get("lint") is not None else ':warning:'}</strong><br>
                      <strong>Test {':white_check_mark:' if run.get("test") else ':x:' if run.get("test") is not None else ':warning:'}</strong><br>
                      <strong>Build {':white_check_mark:' if run.get("build") else ':x:' if run.get("build") is not None else ':warning:'}</strong><br>
                      </details>'''
                      output += textwrap.dedent(moduleOutput)
                      output += "\n"

                  try:
                      o = open(os.environ["GITHUB_STEP_SUMMARY"], 'a')
                  except:
                      print(output)
                  else:
                      with o:
                          o.write(output)

                  exit(0 if allSuccess else 1)

            # Upload Test Artifacts
            - name: Upload CI Artifacts
              uses: actions/upload-artifact@v4
              if: always()
              with:
                  name: test-artifacts
                  if-no-files-found: ignore
                  path: |
                      ./**/test.out.json
                      ./**/coverage.out
